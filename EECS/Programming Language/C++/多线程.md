## 线程间共享数据
### 防止死锁
死锁的原因是多个锁操作一个对象
避免死锁的方式：
1. 按照固定顺序上锁解锁
2. 不要嵌套锁。一个线程在获取一个锁后就不要再次获取同一个锁
3. c++提供了`lock()`来给多个对象上锁，从而避免死锁。
4. 分层上锁：锁高层就不能锁低层

#### lock guard和unique lock
idea是RAII。在普通的lock unlock操作中，中间的操作要是出现了异常，可能就没法unlock了，因此需要设计复杂的异常处理。
lock guard和unique lock在init的时候传入一个锁，自动lock，析构的时候unlock。
unique lock比lock guard灵活很多，可以有lock unlock操作，但开销更大。lock guard好使就不用unique lock

unique lock可以移动，lock guard不行
unique lock可以调用lock unlock，lock guard不行

### 保护共享数据
#### 保护初始化：call once & once flag
```cpp
void undefined_behaviour_with_double_checked_locking()
{

  if(!resource_ptr)  // 1
  {

    std::lock_guard<std::mutex> lk(resource_mutex);
    if(!resource_ptr)  // 2
    {
      resource_ptr.reset(new some_resource);  // 3
    }
}
  resource_ptr->do_something();  // 4
}
```
1和3可能会条件竞争，因为reset并非原子操作。有可能1看到ptr被初始化，但实际上ptr没有指向正确资源。
因此cpp提供了`once_flag`和`call_once`:
```cpp
std::shared_ptr<some_resource> resource_ptr;
std::once_flag resource_flag;  // 1

void init_resource()
{
  resource_ptr.reset(new some_resource);
}

void foo() {

	std::call_once(resource_flag,init_resource); // 可以完整的进行一次初始化
	resource_ptr->do_something();
}
```

#### 保护很少更新的数据结构
c11没有类似东西，可用boost库（第三方）的`boost::shared_mutex`来做
```c++
#include <map>
#include <string>
#include <mutex>
#include <boost/thread/shared_mutex.hpp>

class dns_entry;

class dns_cache
{

  std::map<std::string,dns_entry> entries;

  mutable boost::shared_mutex entry_mutex;
public:

  dns_entry find_entry(std::string const& domain) const
  {

    boost::shared_lock<boost::shared_mutex> lk(entry_mutex);  // 1
    std::map<std::string,dns_entry>::const_iterator const it=

       entries.find(domain);
    return (it==entries.end())?dns_entry():it->second;

  }
  void update_or_add_entry(std::string const& domain,

                           dns_entry const& dns_details)

  {
    std::lock_guard<boost::shared_mutex> lk(entry_mutex);  // 2
    entries[domain]=dns_details;

} };
```
1的shared lock可以共享访问，而在lock guard中，shared mutex则可以独占访问，和普通mutex类似。

#### 嵌套锁
如果非要用嵌套锁，可以用`std::recursive_mutex`。可以锁多次，然后也需要解锁同样多次

## 同步并发操作
### 等待一个事件或其他条件
在等另一个线程的结束时，可以一直while循环等，但浪费。
也可以用`sleep_for()`
推荐使用cpp的工具：条件变量
`std::condition_variable` 和`std::condition_variable_any`

```cpp
std::mutex mut;
std::queue<data_chunk> data_queue;  // 1
std::condition_variable data_cond;

void data_preparation_thread()
{

  while(more_data_to_prepare())
  {

    data_chunk const data=prepare_data();
    std::lock_guard<std::mutex> lk(mut);
    data_queue.push(data);  // 2
    data_cond.notify_one();  // 3

} }

void data_processing_thread()
{

  while(true)
  {

    std::unique_lock<std::mutex> lk(mut);  // 4
    data_cond.wait(
         lk,[]{return !data_queue.empty();});  // 5
    data_chunk data=data_queue.front();
    data_queue.pop();
    lk.unlock();  // 6

    process(data);
    if(is_last_chunk(data))

break; }

}
```
重点在3和5的用法。
5会检查条件和是否上锁，如果条件未通过会阻塞线程进入休眠。而3会唤醒对应的线程。
一个线程安全的queue
```cpp
#include <queue>
#include <memory>
#include <mutex>
#include <condition_variable>

template<typename T>
class threadsafe_queue
{
private:

mutable std::mutex mut; // 1 互斥量必须是可变的 std::queue<T> data_queue; std::condition_variable data_cond;

public:
threadsafe_queue(){}
threadsafe_queue(threadsafe_queue const& other)
{
	std::lock_guard<std::mutex> lk(other.mut);
	data_queue=other.data_queue;
}

void push(T new_value)
{
	std::lock_guard<std::mutex> lk(mut);
	data_queue.push(new_value);
	data_cond.notify_one();
}

void wait_and_pop(T& value)
{
	std::unique_lock<std::mutex> lk(mut);
	data_cond.wait(lk,[this]{return !data_queue.empty();});
	value=data_queue.front();
	data_queue.pop();
}

std::shared_ptr<T> wait_and_pop()
{
	std::unique_lock<std::mutex> lk(mut); 
	data_cond.wait(lk,[this]{return !data_queue.empty();}); 
	std::shared_ptr<T> res(std::make_shared<T>(data_queue.front())); 
	data_queue.pop();  
	return res;
}
bool try_pop(T& value)
{
	std::lock_guard<std::mutex> lk(mut);
	if(data_queue.empty())
	  return false;
	value=data_queue.front();
	data_queue.pop();
	return true;
}

std::shared_ptr<T> try_pop()
{
	std::lock_guard<std::mutex> lk(mut);
	if(data_queue.empty())
	return std::shared_ptr<T>();  
	std::shared_ptr<T> res(std::make_shared<T>(data_queue.front())); 
	data_queue.pop();  
	return res;
}

bool empty() const
{
	std::lock_guard<std::mutex> lk(mut);
	return data_queue.empty();
}
};
```
### 使用future等待一次性事件
#### async
`std::async`会返回一个`std::future`对象，只有对这个对象是用get的时候，才会检查是否就位。
```cpp
#include <future>
#include <iostream>

int find_the_answer_to_ltuae();
void do_other_stuff();
int main()
{
	std::future<int> the_answer=std::async(find_the_answer_to_ltuae); 
	do_other_stuff();  
	std::cout<<"The answer is "<<the_answer.get()<<std::endl;
}
```
async也向内传递参数，第一个参数是函数指针，第二个参数是拥有函数的对象，后面是函数的参数(下图1、2）；可以是第一个参数是函数指针，后面是函数参数。(下图3、4)
```cpp
#include <string>
#include <future>
struct X
{

  void foo(int,std::string const&);
  std::string bar(std::string const&);
};

X x;  
auto f1=std::async(&X::foo,&x,42,"hello"); //1 调用p->foo(42, "hello")，p是指向x的指针
auto f2=std::async(&X::bar,x,"goodbye"); //2 调用tmpx.bar("goodbye")， tmpx是x的拷贝副本 
struct Y  
{
  double operator()(double);
};

Y y;  
auto f3=std::async(Y(),3.141); //3 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到 
auto f4=std::async(std::ref(y),2.718); //4 调用y(2.718)  
X baz(X&);  
std::async(baz,std::ref(x)); // 调用baz(x)  
class move_only  
{  
public:

  move_only();
  move_only(move_only&&)
  move_only(move_only const&) = delete;
  move_only& operator=(move_only&&);
  move_only& operator=(move_only const&) = delete;

  void operator()();
};

auto f5=std::async(move_only()); // 调用tmp()，tmp是通过std::move(move_only())构造得到
```
还可以通过`std::launch` `std::launch::defered`把async的执行推到wait()或者get()
```cpp
auto f6=std::async(std::launch::async,Y(),1.2); // 在新线程上执行  
auto f7=std::async(std::launch::deferred,baz,std::ref(x)); // 在wait()或get()调用时执行 
auto f8=std::async(
              std::launch::deferred | std::launch::async,
				baz,std::ref(x)); // 实现选择执行方式 
auto f9=std::async(baz,std::ref(x));

f7.wait(); // 调用延迟函数
```
#### std::packaged_task<>
可以用来线程间传递任务，其template里是一个函数签名。
下面的代码中，在`post_task_for_gui_thread`是一个打包函数，向gui线程传递了任务。这个函数接受一个任务f，拿他创建了一个packaged task(7)，然后把其返回值标记为一个future(8)再返回(10)。在gui_thread中，5获得了这个task，然后再6执行。执行的结果会在10返回的future中。
```cpp
#include <deque>
#include <mutex>
#include <future>
#include <thread>
#include <utility>

std::mutex m;
std::deque<std::packaged_task<void()> > tasks;

bool gui_shutdown_message_received();
void get_and_process_gui_message();

void gui_thread()  // 1
{

  while(!gui_shutdown_message_received())  // 2
  {

    get_and_process_gui_message();  // 3
    std::packaged_task<void()> task;
    {

      std::lock_guard<std::mutex> lk(m);
      if(tasks.empty())  // 4

        continue;
      task=std::move(tasks.front());  // 5
      tasks.pop_front();

}

task(); // 6 }

}
std::thread gui_bg_thread(gui_thread);

template<typename Func>
std::future<void> post_task_for_gui_thread(Func f)
{

  std::packaged_task<void()> task(f);  // 7
  std::future<void> res=task.get_future();  // 8
  std::lock_guard<std::mutex> lk(m);  // 9
  tasks.push_back(std::move(task));  // 10
  return res;

}
```
#### std::promises
