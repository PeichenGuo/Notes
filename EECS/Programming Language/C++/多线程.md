## 线程间共享数据
### 防止死锁
死锁的原因是多个锁操作一个对象
避免死锁的方式：
1. 按照固定顺序上锁解锁
2. 不要嵌套锁。一个线程在获取一个锁后就不要再次获取同一个锁
3. c++提供了`lock()`来给多个对象上锁，从而避免死锁。
4. 分层上锁：锁高层就不能锁低层

#### lock guard和unique lock
idea是RAII。在普通的lock unlock操作中，中间的操作要是出现了异常，可能就没法unlock了，因此需要设计复杂的异常处理。
lock guard和unique lock在init的时候传入一个锁，自动lock，析构的时候unlock。
unique lock比lock guard灵活很多，可以有lock unlock操作，但开销更大。lock guard好使就不用unique lock

unique lock可以移动，lock guard不行
unique lock可以调用lock unlock，lock guard不行

### 保护共享数据
#### 保护初始化：call once & once flag
```cpp
void undefined_behaviour_with_double_checked_locking()
{

  if(!resource_ptr)  // 1
  {

    std::lock_guard<std::mutex> lk(resource_mutex);
    if(!resource_ptr)  // 2
    {
      resource_ptr.reset(new some_resource);  // 3
    }
}
  resource_ptr->do_something();  // 4
}
```
1和3可能会条件竞争，因为reset并非原子操作。有可能1看到ptr被初始化，但实际上ptr没有指向正确资源。
因此cpp提供了`once_flag`和`call_once`:
```cpp
std::shared_ptr<some_resource> resource_ptr;
std::once_flag resource_flag;  // 1

void init_resource()
{
  resource_ptr.reset(new some_resource);
}

void foo() {

	std::call_once(resource_flag,init_resource); // 可以完整的进行一次初始化
	resource_ptr->do_something();
}
```

#### 保护很少更新的数据结构
c11没有类似东西，可用boost库（第三方）的`boost::shared_mutex`来做
```c++
#include <map>
#include <string>
#include <mutex>
#include <boost/thread/shared_mutex.hpp>

class dns_entry;

class dns_cache
{

  std::map<std::string,dns_entry> entries;

  mutable boost::shared_mutex entry_mutex;
public:

  dns_entry find_entry(std::string const& domain) const
  {

    boost::shared_lock<boost::shared_mutex> lk(entry_mutex);  // 1
    std::map<std::string,dns_entry>::const_iterator const it=

       entries.find(domain);
    return (it==entries.end())?dns_entry():it->second;

  }
  void update_or_add_entry(std::string const& domain,

                           dns_entry const& dns_details)

  {
    std::lock_guard<boost::shared_mutex> lk(entry_mutex);  // 2
    entries[domain]=dns_details;

} };
```
1的shared lock可以共享访问，而在lock guard中，shared mutex则可以独占访问，和普通mutex类似。

#### 嵌套锁
如果非要用嵌套锁，可以用`std::recursive_mutex`。可以锁多次，然后也需要解锁同样多次

## 同步并发操作
### 等待一个事件或其他条件
在等另一个线程的结束时，可以一直while循环等，但浪费。
也可以用`sleep_for()`
推荐使用cpp的工具：条件变量
`std::condition_variable` 和`std::condition_variable_any`

```cpp
std::mutex mut;
std::queue<data_chunk> data_queue;  // 1
std::condition_variable data_cond;

void data_preparation_thread()
{

  while(more_data_to_prepare())
  {

    data_chunk const data=prepare_data();
    std::lock_guard<std::mutex> lk(mut);
    data_queue.push(data);  // 2
    data_cond.notify_one();  // 3

} }

void data_processing_thread()
{

  while(true)
  {

    std::unique_lock<std::mutex> lk(mut);  // 4
    data_cond.wait(

         lk,[]{return !data_queue.empty();});  // 5
    data_chunk data=data_queue.front();
    data_queue.pop();
    lk.unlock();  // 6

    process(data);
    if(is_last_chunk(data))

break; }

}
```
