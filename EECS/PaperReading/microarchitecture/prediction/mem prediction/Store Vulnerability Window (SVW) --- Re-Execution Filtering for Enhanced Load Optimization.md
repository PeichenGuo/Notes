---
Author: "Amir Roth"
Year: 2005
Journel/Conference: "ISCA"
Summary: "针对lsq re-exec带来的dcache带宽压力，本文使用了一个boom filter来过滤掉不需要re-exec的load。这篇没看完，需要的时候再看"
Rate: 3
Question: "None"
Eureka: "None"
---
### Abstract
在[[Memory Ordering --- A Value-Based Approach]]中的re-exec优化，大大增加了dcache的带宽压力。本文通过实现一个boom filter来过滤掉不需要re-exec的load。
本文通过这个filter减少了85%的re-execution

### Motivation
insight：如果一个load的地址在最近较长时间没被写过的，这个load不需要re-execution

### Solution
SSN: 一个递增的store sequence number
SVW：store vulnerability window。一个load只对比它老但没那么老（比如已经commit的store）的store vulnerable。每个ldq entry加一个svw field。这个field是一个SSN。dispatch的时候init，之后可以被修改。
dispatch时init值是上一次retire的store。非常符合直觉，这个是最大的window，从自己这里一直到第一个已经commit的store
本文的创新点就在于SVW的缩减

SSBF：store sequence Bloom filter。一个用pc low bits部分映射到SSN的table。store retire后用其ssn，以更新对应的entry。
SSBF\[st.addr\] = st.SSN

load reissue的时候查下ssbf，如果SSBF\[ld.addr\] > ld.svw，那么说明load的svw内有这么一个store conflict了（在这个load执行前已经执行并修改了ssbf）；如果SSBF\[ld.addr\] < ld.svw，则说明这条load大概没有conflict，不进行re-exec

因此关键在于如何更改 ld.svw

当一个load被前面一个store bypass data了，说明这个store之前的store和这个load无关了。因此ld.svw = st.snn
### Evaluation


### Unsolved Question


### Related Works
#### Later Works
[[Fire-and-Forget --- Load Store Scheduling with No Store Queue at All]]
#### Previous Works
[[Scalable Hardware Memory Disambiguation for High ILP Processors]]也用到了bloom filter
[[Memory Ordering --- A Value-Based Approach]]
#### Similar Works
