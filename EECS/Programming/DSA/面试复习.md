基于OI wiki
# 算法基础
## 贪心
在提高组难度以下的题目中，最常见的贪心有两种。

- 「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。」。
- 「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）

## 排序
### 选择排序
每次找到第i小的元素，然后和第i位元素交换。非常简单的想法。
最优复杂度 平均复杂度 和 最坏复杂度都是O(n2)

### 冒泡排序
每次对比相邻元素，如果左边的元素大，就和右边的交换
第一次扫i个，第二次扫i-1个

在完全有序的情况下，只需要遍历一遍数组，不交换，时间复杂度O(n)
最坏情况是全部要交换，O(n2)

### 插入排序
分为已分类和未分类两个部分，每次都选择一张牌进入已分类的部分，把他插入到其对应位置。
类似打扑克时抓牌理牌的过程
插入排序的最优时间复杂度为 O(n)，在数列几乎有序时效率很高。
插入排序的最坏时间复杂度和平均时间复杂度都为O(n2)
![[Pasted image 20240826160411.png]]

### 计数排序
使用额外的一个数组，其第i个元素是待排序数组中数值为i的元素的个数，然后再用前缀和的方式计算排位
复杂度是O(n+w) 其中w是待排序数的值域


### 基数排序
基数排序（英语：Radix sort）是一种非比较型的排序算法，最早用于解决卡片排序的问题。基数排序将待排序的元素拆分为k个关键字，逐一对各个关键字排序后完成对所有元素的排序。比如字符串排序。
分为MSD和LSD。 Most/Least Significant Digit first.


### 快速排序
快速排序分为三个过程：

1. 将数列划分为两部分（要求保证相对大小关系）；
2. 递归到两个子序列中分别进行快速排序；
3. 不用合并，因为此时数列已经完全有序。

最优和平均时间复杂度是nlogn 最坏情况是n2
最优情况下，分界值都是中位数，因此形成二叉树，是一个nlogn
最坏情况每次pivot都是最值，变成插入排序

在实践中，几乎不可能达到最坏情况，而快速排序的内存访问遵循局部性原理，所以多数情况下快速排序的表现大幅优于堆排序等其他nlogn的排序算法。

我们需要对朴素快速排序思想加以优化。较为常见的优化思路有以下三种

- 通过 **三数取中（即选取第一个、最后一个以及中间的元素中的中位数）** 的方法来选择两个子序列的分界元素（即比较基准）。这样可以避免极端数据（如升序序列或降序序列）带来的退化；
- 当序列较短时，使用 **插入排序** 的效率更高；
- 每趟排序后，**将与分界元素相等的元素聚集在分界元素周围**，这样可以避免极端数据（如序列中大部分元素都相等）带来的退化。

三路快排