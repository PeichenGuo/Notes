---
Author: Zirui Neil Zhao, Josep Torrellas
Year: 2022
Journel/Conference: USENIX Security
Summary: 发现了in-flight ptw和其他memory操作之间的关系，不需要共享地址。使用一个线程创建一个虚假的memory dependency从而导致另一个线程的ptw被squash
Rate: 3
Question: None
Eureka: None
---
# Tags
# Abstract
发现了in-flight ptw和其他memory操作之间的关系，不需要共享地址。使用一个线程创建一个虚假的memory dependency从而导致另一个线程的


# Background
## Microarchitectural Side Channels
channel在两个维度上分为两种：
- stateful。victim对共享资源有永久性改变，比如cache
- stateless。victim的更改是瞬时的，比如port

- direct。直接被victim program创建的，比如load导致cache evict
- indirect。由victim program外的instruction创建，比如prefetcher

## x86页表
四级页表，root由cr3指向。9位索引，每个页表512个entry。一共需要4个load。
由于x86只有48位虚拟地址，因此64位地址的高17位其实等同于第47位。
因此x86把地址空间分为两个，下半给user space，上半给kernel space
2级tlb

## Intel cache
VIPT
L1cache用VA后12位做dependency prediction，如果有dependency，直接squash掉其中一个。这么做比较保守。
最低可以做到word级别的消歧义。
因此本文定义4k-aliasing位11：3相同

## Threat model
attacker在本地要看到victim的特定load store的某些地址位


# Motivation


# Solution
使用一个线程创建一个虚假的memory dependency从而导致另一个线程的ptw被squash
下图是一个ptw load和另一个store有aliasing和没有alias的cycle差距。没别名是100cycle，有别名需要10000cycle，差距足够大
![[Pasted image 20241126002238.png]]
## store-load channel
用attacker的ptw load来攻击victim的store，从而获取11-3位的信息。下图代码可以看到，victim就是一个写。然后attacker就是扫过所有的page，在access page之前先invalid tlb，然后再access确保ptw。从下图折线图可以清楚的看到，能看到secret offset。
简单而言，就是用ptw的四次load来撞victim store的的11-3位
![[Pasted image 20241126002619.png]]
## load -store channel
用attacker的store来攻击victim的ptw。
此时的攻击如图：
![[Pasted image 20241126003144.png]]
attacker的store addr可以攻击到ptw四次的不同load，只要store的11-3和ptw的11-3命中，则该次的延迟就会很长。从而能获取到整个vpn。
下图是建议的代码。注意，下图代码是假设可以通信的，实际上不是这么测得时间。下面的折线图分别是撞出来的4个片段，它的排列组合就是vpn。实际上有很多方式来减少可能性，比如如果我们知道这个access是读heap还是stack，每个地址都是特殊的。还有其他办法，具体看paper
![[Pasted image 20241126002935.png]]
# Evaluation
非常solid，不看了先

# Unsolved Question


# Related Works
## Later Works

## Previous Works

## Similar Works
